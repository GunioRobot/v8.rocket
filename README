

3rd-party libraries
-
* libRocket
 * Thats what this is all about
* v8
 * The v8 Javascript engine
* v8-juice
 * Exposes C++ classes to v8
* v8rocket
 * This project, exposes libRocket's DOM to v8
* boost
 * for boost::bind, otherwise be prepared to create function objects (or use std::bind)

Building v8rocket
-
To build:
<pre>
make v8rocket <VARS>
</pre>

VARS should be:

* ROCKET_HOME=<rocket project directory>
 * Defaults to cwd
 * Alternatively, you can directly specify ROCKET_CXXFLAGS and ROCKET_SRCPATH, in which case make sure ROCKET_CXXFLAGS has the include path for rocket, and ROCKET_SRCPATH is the Source sub-directory in the project's directory
* V8_HOME=<v8 project directory>
 * Defaults to cwd
 * Alternatively, you can directly specify V8_CXXFLAGS, in which case make sure V8_CXXFLAGS has the include path for v8
* V8JUICE_HOME=<v8-juice project directory>
 * Alternatively, you can directly specify V8JUICE_CXXFLAGS, in which case make sure V8JUICE_CXXFLAGS has the include path for v8-juice
* V8ROCKET_HOME=<v8rocket project directory>
 * Defaults to cwd, no need to set it if executing from within the project directory
* V8ROCKET_OBJPATH=<v8rocket object output directory>
 * Defaults to cwd
* V8ROCKET_LIBPATH=<v8rocket library output directory>
 * Defaults to cwd
* CXXFLAGS=<additional C++ FLAGS to be used>
 * Add things like -DSTATIC_LIB here etc., see libRocket docs for more info
 * Add any additional flags for v8, v8-juice etc.

To clean:
<pre>
make clean.v8rocket <SAME VARS AS WHEN BUILDING>
</pre>

Example:
<pre>
#Clean the project
make clean.v8rocket V8_HOME=../projects/v8 V8JUICE_HOME=../projects/v8-juice V8ROCKET_HOME=./ CXXFLAGS="-DSTATIC_LIB"
#Build the project
make v8rocket V8_HOME=../projects/v8 V8JUICE_HOME=../projects/v8-juice V8ROCKET_HOME=./ CXXFLAGS="-DSTATIC_LIB"
</pre>


Integrating into your project
-
Make sure your project has access to the following project's include directores:

* v8
* v8-juice
* libRocket
* v8rocket (this project)

Example usage
-

Initalize Rocket as usual. Then call Rocket::Core::JS::Initialise() immediately afterward:
<pre>
	Rocket::Core::Initialise();
	Rocket::Controls::Initialise();
  Rocket::Core::JS::Initialise();
</pre>

Create your Core::Context and load your document as usual.

The main v8/rocket glue is the Rocket::Core::JS::Browser object. Create a Browser with your Core::Context and Core::ElementDocument. The Browser object should stay alive longer than the Context object (since the JS might have installed callback EventListener's into the DOM).

Create the Browser object like so:
<pre>
  Rocket::Core::Context* rocketContext = Rocket::Core::CreateContext(
    Rocket::Core::String("Test"),
    Rocket::Core::Vector2i(mWindow->getWidth(), mWindow->getHeight()),
    &(*render_interface));
  assert(r);
  
  rocketContext->LoadMouseCursor("cursor.rml")->RemoveReference();
  rocketContext->ShowMouseCursor(true)
  
  Rocket::Core::ElementDocument* rocketDocument = rocketContext->LoadDocument("demo.rml");
  assert(rocketDocument);
  
  rocketDocument->Show();
  
  Rocket::Core::JS::Browser* browser = new Rocket::Core::JS::Browser(rocketContext, rocketDocument);
  
  //Browser will increase the ref counts of both, so u can safely remove their references
  rocketContext->RemoveReference();
  rocketDocument->RemoveReference();
  
</pre>

And finally, to execute Javascript:
<pre>
//You can probably put this anywhere, I put this in my keyboard handler, and execute it on a certain key
  {
    typedef Rocket::Core::JS::Browser Browser;
    
    //I think this must be somewhere up the stack in order to do anything v8, dunno
    v8::Locker locker;
    
    //All handles created below will be reaped when this is destroyed
    v8::HandleScope handle_scope;
    
    //In order to do anything v8, we must be inside a valid v8 context, this will make the rest
    // of this cope in our browser's v8 context
    v8::Context::Scope context_scope(browser->v8Context());
    
    //I load this string from a file, see v8 docs and examples on how to create strings etc.
    v8::Handle<v8::String> script_source = v8::String::New("document.getElementById('output').innerHTML = \"CAN YOU SEE ME\"");
    
    assert(!script_source.IsEmpty());
    
    //Compile the script
    v8::Handle<v8::Script> script = browser->compile(ReadFile(filename),
      v8::String::New(filename),
      //This is using boost::bind to make a function object that takes a v8::TryCatch
      //The utility function Browser::ReportException is provided; it outputs to the specified
      // output stream, and takes the TryCatch as the first argument. You can provide your
      // own function object as well, and/or create them using boost::bind, or std::bind etc.
      boost::bind(BrowserT::ReportException<std::ostream>, _1, boost::ref(std::cout)));
    
    //Run the script
    v8::Handle<v8::Value> result = browser->run(script,
      //See above for explanation of this parameter
      boost::bind(Browser::ReportException<std::ostream>, _1, boost::ref(std::cout)) );
  }
  //Now that we are out of scope, all the Handles will be reaped.
  //Don't just store a copy of one of the above Handles; it will be invalid.
  //If you want to store a compiled script accross calls, or otherwise outside this scope,
  // you would need to use a Persistent handle, and allocate it using
  // v8::Persistent<v8::Script>::New(script)
</pre>


Do's:
-
* Call Rocket::Core::Initialise(), then Rocket::Controls::Initialise(), then Rocket::Core::JS::Initialise(), if you fail to do this, undefined behavior (BAD) will result

Don'ts:
-
* Don't use rocket debugger (don't include Core/Debugger.h), or perhaps that ok, but don't initalize the context with the debugger


TODO:
--

* Warn about v8-juice version
* Wrap controls
* Implement removeEvent
* Implement/Use EventListenerInstancer?
* Finish DOM (of course)
* Test suites?
* Example
* Example html/javascript
* Script tag

WORKAROUNDS:
-
* I don't think it is possible to get access to the HEAD tag etc. in libRocket
* In libRocket, ElementDocument is the BODY tag; in DOM, HTMLDocument is usually an HTML tag (equivelent to #root, which here is a generic element)
* In libRocket, GetOwnerDocument() returns the BODY tag, in DOM, ownerDocument points to the HTMLDocument

